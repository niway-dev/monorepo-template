---
title: Repository Pattern Refactoring Summary
description: Summary of the repository pattern implementation and refactoring
---

# Repository Pattern Refactoring Summary

This document summarizes the refactoring work done to implement the proper Repository pattern following Domain-Driven Design principles.

---

## ğŸ¯ What Was Changed

### Before (âŒ Anti-pattern)

```
packages/db/src/queries/your-entity.ts  â† Direct query functions
  â””â”€ findPaginatedYourEntities()       â† Called directly from routes

apps/server/src/routes/your-entities.ts
  â””â”€ Direct SQL/ORM queries in route handlers
```

**Problems:**

- Domain logic mixed with infrastructure
- No separation of concerns
- Hard to test
- Tight coupling to Drizzle ORM
- Raw database queries in routes

---

### After (âœ… Clean Architecture)

```
packages/domain/src/repositories/
  â””â”€ your-entity.repository.ts         â† Interface (contract)

packages/database/src/repositories/
  â””â”€ your-entity.repository.drizzle.ts â† Implementation

packages/database/src/mappers/
  â””â”€ your-entity.mapper.ts             â† DB â†” Domain conversion

apps/server/src/routes/
  â””â”€ your-entities.ts                  â† Uses repository interface
```

**Benefits:**

- âœ… Clean separation of concerns
- âœ… Domain independent of infrastructure
- âœ… Easy to test with mocks
- âœ… Can swap Drizzle for Prisma
- âœ… Rich domain model
- âœ… Follows DDD principles

---

## ğŸ“¦ Files Created

### 1. Repository Interface (Domain Layer)

**Location:** `packages/domain/src/repositories/your-entity.repository.ts`

```typescript
export interface IYourEntityRepository {
  findById(id: string, userId: string): Promise<YourEntityBase | null>;
  findPaginated(userId: string, params: PaginationParams): Promise<PaginatedResult<YourEntityBase>>;
  save(yourEntity: YourEntityBase): Promise<void>;
  update(id: string, userId: string, data: Partial<YourEntityBase>): Promise<YourEntityBase>;
  delete(id: string, userId: string): Promise<void>;
}
```

---

### 2. Repository Implementation (Database Layer)

**Location:** `packages/database/src/repositories/your-entity.repository.drizzle.ts`

```typescript
export class YourEntityRepositoryDrizzle implements IYourEntityRepository {
  constructor(private readonly db: NeonHttpDatabase) {}

  async findPaginated(userId: string, params: PaginationParams) {
    // Drizzle queries here
    // Returns domain entities via mapper
  }

  // ... other methods
}
```

---

### 3. Mapper (Database Layer)

**Location:** `packages/database/src/mappers/your-entity.mapper.ts`

```typescript
export class YourEntityMapper {
  static toDomain(row: any): YourEntityBase {
    // Convert DB row to domain entity
  }

  static toPersistence(yourEntity: YourEntityBase): any {
    // Convert domain entity to DB record
  }
}
```

---

### 4. Documentation

**Location:** `apps/fumadocs/content/docs/architecture/repository-pattern.mdx`

Comprehensive guide covering:

- Repository pattern principles
- Package structure
- Implementation examples
- Testing strategies
- Best practices

---

## ğŸ”„ Files Modified

### 1. Server Routes

**Before:**

```typescript
// Direct database queries in route
const entities = await db
  .select()
  .from(yourEntityTable)
  .where(and(eq(yourEntityTable.userId, user.id), isNull(yourEntityTable.deletedAt)))
  .orderBy(desc(yourEntityTable.updatedAt))
  .limit(pagination.limit)
  .offset(pagination.offset);
```

**After:**

```typescript
// Clean, abstracted repository call
const result = await yourEntityRepo.findPaginated(user.id, {
  page: query.page || 1,
  limit: query.limit || 10,
});
```

---

### 2. Package Exports

**`packages/domain/package.json`:**

```json
{
  "exports": {
    "./repositories": "./src/repositories/index.ts"
  }
}
```

**`packages/database/package.json`:**

```json
{
  "exports": {
    "./repositories": "./src/repositories/index.ts",
    "./mappers": "./src/mappers/index.ts"
  }
}
```

---

## ğŸ—‘ï¸ Files Deleted

- âŒ `packages/db/src/queries/your-entity.ts` - Deprecated query functions
- âœ… Replaced by repository pattern

---

## ğŸ“Š Impact Analysis

### Code Organization

| Aspect                 | Before       | After          |
| ---------------------- | ------------ | -------------- |
| Separation of Concerns | âŒ Mixed     | âœ… Clear       |
| Testability            | âŒ Hard      | âœ… Easy        |
| Domain Independence    | âŒ Coupled   | âœ… Independent |
| Reusability            | âŒ Low       | âœ… High        |
| Maintainability        | âŒ Difficult | âœ… Simple      |

---

### Architecture Flow

**Before:**

```
Route â†’ Direct DB Query â†’ Response
```

**After:**

```
Route â†’ Repository Interface â†’ Repository Implementation â†’ Mapper â†’ DB
                                                          â†“
                                                   Domain Entity
```

---

## ğŸ§ª Testing Benefits

### Before (Hard to Test)

```typescript
// Need real database to test routes
test('GET /your-entities', async () => {
  const response = await request(app).get('/your-entities');
  // Requires database connection
});
```

### After (Easy to Test)

```typescript
// Mock repository for testing
class MockYourEntityRepository implements IYourEntityRepository {
  async findPaginated(userId: string, params: PaginationParams) {
    return mockData;
  }
}

test('GET /your-entities', async () => {
  const mockRepo = new MockYourEntityRepository();
  // Test with mock data, no database needed
});
```

---

## ğŸ“š Related Documentation

- [Repository Pattern Guide](/docs/architecture/repository-pattern) - Full implementation guide
- [Domain-Driven Design](/docs/domain-architecture-patterns) - DDD principles
- [Authentication Architecture](/docs/authentication/overview) - Similar clean architecture

---

## ğŸ¯ Next Steps

### Recommended Refactorings

1. **Comments Repository**
   - Create interface in `packages/domain/src/repositories/`
   - Implement in `packages/database/src/repositories/`
   - Add mapper for DB â†” Domain conversion

2. **Related Details Repository**
   - Follow same pattern
   - Extract from direct queries

3. **Application Services Layer**
   - Create `packages/application/` for use cases
   - Move business logic from routes to application services
   - Example: `CreateYourEntity`, `UpdateYourEntity`, etc.

---

## ğŸ’¡ Key Learnings

1. **Repository Interface in Domain**
   - Defines what data operations are needed
   - Independent of infrastructure
   - Easy to mock for testing

2. **Repository Implementation in Database**
   - Concrete implementation with ORM
   - Can be swapped without affecting domain
   - Encapsulates all SQL/ORM logic

3. **Mapper Pattern**
   - Converts between DB and domain representations
   - Keeps domain entities clean
   - Allows different DB schemas vs domain models

4. **Clean Routes**
   - Routes become thin orchestrators
   - Business logic in domain/application layer
   - Infrastructure concerns in database layer

---

## ğŸš€ Migration Guide

If you have other features using direct queries, follow these steps:

1. **Create Repository Interface** in `packages/domain/`
2. **Create Repository Implementation** in `packages/database/`
3. **Create Mapper** for DB â†” Domain conversion
4. **Update Routes** to use repository
5. **Delete Old Query Files**
6. **Write Tests** with mock repositories

---

## ğŸ“ Support

For questions about this refactoring or the repository pattern:

- See: [Repository Pattern Guide](/docs/architecture/repository-pattern)
- Check: Architecture discussion docs in `/architecture-discussion/`

---

_Last Updated: {new Date().toISOString().split('T')[0]}_
