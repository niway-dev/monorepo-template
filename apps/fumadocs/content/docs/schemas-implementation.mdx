---
title: Schemas Implementation Guide
description: How to use Zod schemas from the domain package across the application
date: 2025-12-25
tags:
  - schemas
  - validation
  - implementation
  - zod
---

# Schemas Implementation Guide

This guide explains how to use the Zod schemas from the `@monorepo-template/domain` package across the monorepo-template application.

## Package Structure

```
packages/domain/src/
‚îú‚îÄ‚îÄ constants/
‚îÇ   ‚îú‚îÄ‚îÄ currency.ts
‚îÇ   ‚îú‚îÄ‚îÄ your-entity-status.ts
‚îÇ   ‚îî‚îÄ‚îÄ comment-type.ts
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îú‚îÄ‚îÄ api-response.ts
‚îÇ   ‚îî‚îÄ‚îÄ result.ts
‚îî‚îÄ‚îÄ schemas/              üëà NEW
    ‚îú‚îÄ‚îÄ your-entity.ts
    ‚îú‚îÄ‚îÄ your-entity-details.ts
    ‚îú‚îÄ‚îÄ comment.ts
    ‚îî‚îÄ‚îÄ index.ts
```

## Zod v4 Syntax

**IMPORTANT**: This project uses Zod v4. Always use the modern syntax:

```typescript
// ‚úÖ Zod v4 (CORRECT)
z.uuid()          // Not z.string().uuid()
z.url()           // Not z.string().url()
z.email()         // Not z.string().email()
z.date()          // For date objects
z.coerce.date()   // To coerce strings to dates

// ‚ùå Zod v3 syntax (WRONG - DO NOT USE)
z.string().uuid()
z.string().url()
z.string().email()
```

## Schema Organization

Each entity has its own schema file with:

- **Base schema**: Complete domain model
- **Create schema**: Fields for creation (derived from base)
- **Update schema**: Fields for updates (derived from base/create)
- **Additional schemas**: Filters, partials, etc. as needed

### Example: Your Entity Schemas

```typescript
// packages/domain/src/schemas/your-entity.ts
import { z } from "zod";
import { YOUR_ENTITY_STATUSES, CURRENCIES } from "../constants";

// Base schema - source of truth (using Zod v4 syntax)
export const yourEntityBaseSchema = z.object({
  id: z.uuid(),                     // ‚úÖ Zod v4: z.uuid() not z.string().uuid()
  name: z.string().min(1, "Name is required"),
  status: z.enum([
    YOUR_ENTITY_STATUSES.ACTIVE,
    YOUR_ENTITY_STATUSES.REJECTED,
    YOUR_ENTITY_STATUSES.CANCELLED,
    YOUR_ENTITY_STATUSES.COMPLETED,
  ]),
  salary: z.number().min(0).nullable(),
  currency: z.enum([CURRENCIES.USD, CURRENCIES.PEN]),
  userId: z.string(),
  createdAt: z.coerce.date(),
  updatedAt: z.coerce.date(),
});

// Create schema - derived from base
export const createYourEntitySchema = yourEntityBaseSchema
  .pick({
    name: true,
    status: true,
  })
  .extend({
    salary: z.number().min(0).optional(),
    currency: z.enum([CURRENCIES.USD, CURRENCIES.PEN]).optional(),
  });

// Update schema
export const updateYourEntitySchema = createYourEntitySchema;

// Type exports
export type YourEntityBase = z.infer<typeof yourEntityBaseSchema>;
export type CreateYourEntity = z.infer<typeof createYourEntitySchema>;
export type UpdateYourEntity = z.infer<typeof updateYourEntitySchema>;
```

## Backend Usage

### Elysia Route Validation

```typescript
// apps/server/src/routes/your-entities.ts
import { Elysia, t } from "elysia";
import { updateYourEntitySchema } from "@monorepo-template/domain/schemas";

export const yourEntityRoutes = new Elysia({ prefix: "/api/your-entities" })
  .put(
    "/:id",
    async ({ params, body }) => {
      // body is automatically validated and typed
      const updated = await db
        .update(yourEntity)
        .set({
          name: body.name,
          status: body.status,
          salary: body.salary,
          currency: body.currency,
        })
        .where(eq(yourEntity.id, params.id))
        .returning();

      return successBody(updated);
    },
    {
      params: t.Object({
        id: t.String(),
      }),
      body: updateYourEntitySchema, // üëà Zod schema from domain
    },
  );
```

### Benefits:

- ‚úÖ Automatic validation
- ‚úÖ Type inference
- ‚úÖ Consistent validation rules
- ‚úÖ Single source of truth

## Frontend Usage

### Form Validation with React Hook Form

```typescript
// apps/web/src/components/your-entity/your-entity-form.tsx
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  updateYourEntitySchema,
  type UpdateYourEntity
} from "@monorepo-template/domain/schemas";

export function YourEntityForm() {
  const form = useForm<UpdateYourEntity>({
    resolver: zodResolver(updateYourEntitySchema),
    defaultValues: {
      name: "",
      status: "active",
    },
  });

  const onSubmit = (data: UpdateYourEntity) => {
    // data is fully typed and validated
    updateMutation.mutate(data);
  };

  return (
    <form onSubmit={form.handleSubmit(onSubmit)}>
      {/* form fields */}
    </form>
  );
}
```

### Type-Safe Hooks

```typescript
// apps/web/src/hooks/use-your-entities.ts
import { useMutation } from "@tanstack/react-query";
import type { UpdateYourEntity } from "@monorepo-template/domain/schemas";

export function useUpdateYourEntity(id: string) {
  return useMutation({
    mutationFn: async (data: UpdateYourEntity) => {
      const response = await api.yourEntities[id].put(data);
      if (response.error) throw new Error(response.error.message);
      return response.data;
    },
  });
}
```

## Schema Derivation Patterns

### Using `.pick()` and `.omit()`

```typescript
// Pick specific fields
export const createSchema = baseSchema.pick({
  name: true,
  status: true,
});

// Omit specific fields
export const updateSchema = baseSchema.omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});
```

### Using `.extend()`

```typescript
// Add or override fields
export const createSchema = baseSchema
  .pick({ name: true })
  .extend({
    // Make salary optional
    salary: z.number().min(0).optional(),
  });
```

### Using `.partial()`

```typescript
// Make all fields optional
export const partialUpdateSchema = updateSchema.partial();
```

### Using `.required()`

```typescript
// Make all fields required
export const strictSchema = baseSchema.required();
```

## Available Schemas

### Your Entity

```typescript
import {
  yourEntityBaseSchema,
  createYourEntitySchema,
  updateYourEntitySchema,
  partialUpdateYourEntitySchema,
  filterYourEntitySchema,
  type YourEntityBase,
  type CreateYourEntity,
  type UpdateYourEntity,
} from "@monorepo-template/domain/schemas";
```

### Your Entity Details

```typescript
import {
  yourEntityDetailsBaseSchema,
  createYourEntityDetailsSchema,
  updateYourEntityDetailsSchema,
  type YourEntityDetailsBase,
  type CreateYourEntityDetails,
  type UpdateYourEntityDetails,
} from "@monorepo-template/domain/schemas";
```

### Comment

```typescript
import {
  commentBaseSchema,
  createCommentSchema,
  updateCommentSchema,
  type CommentBase,
  type CreateComment,
  type UpdateComment,
} from "@monorepo-template/domain/schemas";
```

## Best Practices

### 1. Always Use Schemas for Validation

```typescript
// ‚úÖ Good - use schema
const result = createYourEntitySchema.safeParse(data);
if (!result.success) {
  throw new Error(result.error.message);
}

// ‚ùå Bad - manual validation
if (!data.name || data.name.length === 0) {
  throw new Error("Name is required");
}
```

### 2. Derive Schemas, Don't Duplicate

```typescript
// ‚úÖ Good - derive from base
export const updateSchema = baseSchema.pick({ name: true });

// ‚ùå Bad - duplicate definition
export const updateSchema = z.object({
  name: z.string().min(1),
});
```

### 3. Export Types

```typescript
// ‚úÖ Good - export inferred types
export type CreateYourEntity = z.infer<typeof createYourEntitySchema>;

// ‚ùå Bad - define types separately
export type CreateYourEntity = {
  name: string;
  status: string;
};
```

### 4. Use Descriptive Error Messages

```typescript
// ‚úÖ Good - clear messages
z.string().min(1, "Name is required")
z.number().min(0, "Value must be positive")

// ‚ùå Bad - no messages
z.string().min(1)
z.number().min(0)
```

### 5. Handle Validation Errors Gracefully

```typescript
// Frontend
const result = schema.safeParse(data);
if (!result.success) {
  // Show user-friendly errors
  result.error.errors.forEach((err) => {
    toast.error(`${err.path.join('.')}: ${err.message}`);
  });
}

// Backend
try {
  const validated = schema.parse(body);
} catch (error) {
  if (error instanceof z.ZodError) {
    throw new BadRequestError(error.errors[0].message);
  }
}
```

## Testing Schemas

### Unit Tests

```typescript
import { describe, it, expect } from "vitest";
import { createYourEntitySchema } from "@monorepo-template/domain/schemas";

describe("createYourEntitySchema", () => {
  it("should validate valid data", () => {
    const data = {
      name: "Acme Corp",
      status: "active",
    };

    const result = createYourEntitySchema.safeParse(data);
    expect(result.success).toBe(true);
  });

  it("should reject empty name", () => {
    const data = {
      name: "",
      status: "active",
    };

    const result = createYourEntitySchema.safeParse(data);
    expect(result.success).toBe(false);
  });

  it("should accept optional salary", () => {
    const data = {
      name: "Acme Corp",
      status: "active",
      salary: 100000,
    };

    const result = createYourEntitySchema.safeParse(data);
    expect(result.success).toBe(true);
  });
});
```

## Migration from Elysia `t` to Zod

### Before (Elysia `t`)

```typescript
{
  body: t.Object({
    name: t.String({ minLength: 1 }),
    status: t.Union([
      t.Literal("active"),
      t.Literal("rejected"),
    ]),
    salary: t.Optional(t.Number({ minimum: 0 })),
  }),
}
```

### After (Zod schema)

```typescript
{
  body: updateYourEntitySchema, // from @monorepo-template/domain/schemas
}
```

### Benefits of Migration:

- ‚úÖ Shared between frontend and backend
- ‚úÖ Better error messages
- ‚úÖ Easier to derive and compose
- ‚úÖ Type inference works better
- ‚úÖ More ecosystem support (React Hook Form, etc.)

## Troubleshooting

### Schema Not Found

If you get import errors:

1. Build the domain package:

```bash
bun run --filter=@monorepo-template/domain build
```

2. Check package.json exports:

```json
{
  "exports": {
    "./schemas": {
      "types": "./dist/schemas.d.mts",
      "import": "./dist/schemas.mjs"
    }
  }
}
```

### Type Inference Issues

If types aren't inferred correctly:

```typescript
// Use explicit type annotation
const data: CreateYourEntity = {
  name: "Acme",
  status: "active",
};

// Or use satisfies
const data = {
  name: "Acme",
  status: "active",
} satisfies CreateYourEntity;
```

### Validation Errors in Production

Always use `.safeParse()` instead of `.parse()` to avoid throwing:

```typescript
// ‚úÖ Good - doesn't throw
const result = schema.safeParse(data);
if (!result.success) {
  // handle error
}

// ‚ùå Bad - throws error
const validated = schema.parse(data); // throws ZodError
```

## Next Steps

- Review [Domain Architecture Patterns](/docs/domain-architecture-patterns) for architectural decisions
- See [Backend Best Practices](/docs/backend) for API patterns
- Check [Constants Pattern](/docs/constants-pattern) for using constants with schemas
